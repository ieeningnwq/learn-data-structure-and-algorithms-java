# 1.1 时间复杂度

程序运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？尽管有许多复杂的因素影响着我们对程序的运行时间的理解，但是原则上，我们仍然可能构造出一个数学模型来描述任意程序的运行时间。一个程序运行的时间主要和两点有关：

1. 执行每条语句的耗时；
2. 执行每条语句的频率；

前者取决于计算机、`Java`编译器和操作系统，后者取决于程序本身和输入。如果对于程序的所有部分我们都知道了这些性质，可以将它们相乘并将程序中所有指令的成本相加得到总运行时间。

例如在以下代码中，输入数据大小为`n`：

```java
// 在某运行平台下
void algorithm(int n) {
    int a = 2;  // 赋值 1 ns
    a = a + 1;  // 加法 1 ns
    a = a * 2;  // 乘法 10 ns
    // 循环 n 次
    for (int i = 0; i < n; i++) {  // 1 ns ，每轮都要执行 i++
        System.out.println(0);     // 打印 5 ns
    }
}
```

根据以上方法，可以得到算法的运行时间为$6n+12$ ns：

$$1+1+10+(1+5)*n=6n+12$$

但实际上，统计算法的运行时间既不合理也不现实。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。



