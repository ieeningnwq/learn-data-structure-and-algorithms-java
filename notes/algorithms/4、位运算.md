# 位运算

## 4.1 进制转换

### 4.1.1 进制的概念

进制即进位计数制，是利用固定的数字符号和统一的规则的带进位的计数方法。任何一种进位计数制都有一个基数，基数为 $X$ 的进位计数制称为 $X$ 进制，表示每一个数位上的数运算时都是逢 $X$ 进一。对于一个 $X$ 进制的数，其具体数值由其中的每个数码和数码所在的数位决定。整数部分从右往左的第 $m$ 个数位表示的权重是 $X^m$ ，其中 $m$ 最小为 $0$ ；小数部分从左往右的第 $n$ 个数位表示的权重是 $X^{-n}$  ，其中 $n$ 最小为 $1$。

十进制的 $123.45$ 可以写成如下形式：

$$123.45=1\times10^2+2\times10^1+3\times10^0+4\times10^{-1}+5\times10^{-2}$$

八进制的 $720.5$ 可以写成如下形式：

$$720.5=7\times8^2+2\times8^1+0\times8^0+5\times8^{-1}$$

### 4.1.2 常见的进制

日常生活中，最常用的进制是十进制。十进制包括十个数码： $0,1,2,3,4,5,6,7,8,9$ 。计算机采用的进制是二进制。二进制包括两个数码： $0,1$ 。八进制和十六进制也是常见的进制。八进制包含八个数码： $0,1,2,3,4,5,6,7$ 。十六进制包含十六个数码，除了 $0$ 到 $9$ 以外，还有 $A,B,C,D,E,F$ ，分别对应十进制下的 $10,11,12,13,14,15$ 。

### 4.1.3 进制间的转换

#### 4.1.3.1 非十进制转十进制

将非十进制数转成十进制数，只要将每个数位的加权和即可。例如，将八进制数 $720.5_{(8)}$ 转成十进制：

$$720.5_{(8)}=7\times8^2+2\times8^1+0\times8^0+5\times8^{-1}$$

#### 4.1.3.2 十进制转非十进制

将十进制数转成 $X$ 进制数，需要对整数部分和小数部分分别转换。

对于整数部分，转换方式是将十进制数的整数部分每次除以 $X$ 直到变成 $0$ ，并记录每次的余数，反向遍历每次的余数即可得到 $X$ 进制表示。

例如，将十进制数 $50$ 转成二进制：

$$50÷2=25 余 0\\25÷2=12 余 1\\12÷2=6 余 0\\6÷2=3 余 0\\3÷2=1 余 1\\1÷2=0 余 1$$

反向遍历每次的余数，依次是 $1,1,0,0,1,0$ ，因此十进制数 $50$ 转成二进制数是 $110010_{(2)}$  。

对于小数部分，转换方式是将十进制数的小数部分每次乘以 $X$ 直到变成 $0$ ，并记录每次的整数部分，正序遍历每次的整数部分即可得到 $X$ 进制表示。

例如，将十进制数 $0.6875$ 转成二进制：

$$0.6875×2=1.375 整 1\\0.375×2=0.75 整 0\\0.75×2=1.5 整 1\\0.5×2=1 整 1$$

正序遍历每次的整数部分，依次是 $1,0,1,1$ ，因此十进制数 $0.6875$ 转成二进制数是 $0.1011_{(2)}$ 。

需要注意的是，在一种进制下的有限小数，转成另一种进制之后可能变成无限循环小数。例如，十进制数 $0.2$ 转成二进制数是 $0.\dot{0}01\dot{1}_{2}$ 。

#### 4.1.3.3 其他进制间的转换

如果需要在两个不同的非十进制之间转换，常规的思路是先转成十进制数，再转成目标进制数。在一些特殊情况下，也可以不经过十进制，直接进行转换。例如，将二进制数转成八进制数或十六进制数，以及将八进制数或十六进制数转成二进制数，都不需要经过十进制。一位八进制数可以表示成三位二进制数，一位十六进制数可以表示成四位二进制数。例如，对于二进制数 $101110010_{(2)}$ ，按照三位一组进行分组，可以得到 $101∣110∣010$ ，按照四位一组进行分组，可以得到 $1∣0111∣0010$ ，因此转成八进制数是 $562_{(8)}$  ，转成十六进制数是 $172_{(16)}$ 。

## 4.2 位运算符的概念和性质

计算机采用二进制，二进制包括两个数码：$0$ 和 $1$。在计算机的底层，一切运算都是基于位运算实现的。

位运算共有 $6$ 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。上述位运算中，只有取反是一元运算，其余的都是二元运算。

### 4.2.1 与、或、异或和取反

与运算的符号是 $\&$，运算规则是：对于每个二进制位，当两个数对应的位都为 $1$ 时，结果才为 $1$ ，否则结果为 $0$ 。

$$0 \& 0=0\\0 \& 1=0\\1 \& 0=0\\1 \& 1=1$$

或运算的符号是 $∣$，运算规则是：对于每个二进制位，当两个数对应的位都为 $0$ 时，结果才为 $0$，否则结果为 $1$ 。

$$0 \vert 0=0\\0 \vert 1=1\\1 \vert 0=1\\1 \vert 1=1$$

异或运算的符号是 $\oplus$（在代码中用 $∧$ 表示异或），运算规则是：对于每个二进制位，当两个数对应的位相同时，结果为 $0$ ，否则结果为 $1$。

$$0 \oplus 0=0\\0 \oplus 1=1\\1 \oplus 0=1\\1 \oplus 1=0$$

取反运算的符号是 $∼$，运算规则是：对一个数的每个二进制位进行取反操作， $0$ 变成 $1$ ， $1$ 变成 $0$ 。

$$ ∼0=1\\∼1=0$$

下面看一个例子，参与运算的数字都采用有符号的 $8$ 位二进制表示。

$46$ 的二进制表示是 $00101110$ ， $51$ 的二进制表示是 $00110011$。考虑以下位运算的结果。

+ $46\&51$ 的结果是 $34$ ，对应的二进制表示是 $00100010$；
+ $46\vert51$ 的结果是 $63$ ，对应的二进制表示是 $00111111$；
+ $46\oplus51$ 的结果是 $29$ ，对应的二进制表示是 $00011101$；
+ $∼46$ 的结果是 $−47$ ，对应的二进制表示是 $11010001$；
+ $∼51$ 的结果是 $-52$ ，对应的二进制表示是 $11001100$；

### 4.2.2 移位运算

移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。

左移运算的符号是 $<<$ 。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 $0$ 。对于左移运算，算术移位和逻辑移位是相同的。

右移运算的符号是 $>>$ 。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定：

+ 算术右移时，高位补最高位；
+ 逻辑右移时，高位补 $0$ 。

### 4.2.3 移位运算与乘除法的关系

移位运算与乘除法有密切的关联性。由于计算机的底层的一切运算都是基于位运算实现的，因此使用移位运算实现乘除法的效率显著高于直接乘除法的效率。

左移运算对应乘法运算。将一个数左移 $k$ 位，等价于将这个数乘以 $2^k$  。例如，$29$ 左移 $2$ 位的结果是 $116$ ，等价于 $29×4$ 。当乘数不是 $2$ 的整数次幂时，可以将乘数拆成若干项 $2$ 的整数次幂之和，例如， $a×6$ 等价于 $(a<<2)+(a<<1)$ 。对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况。

算术右移运算对应除法运算。将一个数右移 $k$ 位，相当于将这个数除以 $2^k$ 。例如， $50$ 右移 $2$ 位的结果是 $12$ ，等价于 $50/4$ ，结果向下取整。

从程序实现的角度，考虑程序中的整数除法，是否可以说，将一个数（算术）右移 $k$ 位，和将这个数除以 $2^k$ 等价？对于 $0$ 和正数，上述说法是成立的，整数除法是向 $0$ 取整，右移运算是向下取整，也是向 $0$ 取整。但是对于负数，上述说法就不成立了，整数除法是向 $0$ 取整，右移运算是向下取整，两者就不相同了。例如， $(−50)>>2$ 的结果是 $−13$ ，而 $(−50)/4$ 的结果是 $−12$，两者是不相等的。因此，将一个数（算术）右移 $k$ 位，和将这个数除以 $2^k$ 是不等价的。

### 4.2.4 位运算的性质

位运算的性质有很多，此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。

+ 幂等律：$a \& a=a,\quad a ∣ a=a$（注意异或不满足幂等律）；
+ 交换律：$a \& b=b \& a,\quad a ∣ b=b ∣ a,\quad a\oplus b=b\oplus a$；
+ 结合律：$(a \& b) \& c=a \& (b \& c),\quad (a ∣ b) ∣ c=a ∣ (b ∣ c),\quad (a\oplus b)\oplus c=a\oplus(b\oplus c)$ ；
+ 分配律：$(a \& b) ∣ c=(a ∣ c) \& (b ∣ c),\quad (a ∣ b) \& c=(a \& c) ∣ (b \& c),\quad (a\oplus b) \& c=(a \& c)\oplus(b \& c)$ ；
+ 德·摩根律：$∼(a \& b)=(∼a) ∣ (∼b),\quad ∼(a ∣ b)=(∼a) \& (∼b)$ ；
+ 取反运算性质：$−1=∼0,\quad −a=∼(a−1)$ ；
+ 与运算性质：$a \& 0=0,\quad a \& (−1)=a,\quad a \& (∼a)=0$ ；
+ 或运算性质：$a ∣ 0=a,\quad a ∣ (∼a)=−1$ ；
+ 异或运算性质： $a\oplus0=a,\quad  a\oplus a=0$ ；
+ 其他性质：
  + $a \& (a−1)$ 的结果为将 $a$ 的二进制表示的最后一个 $1$ 变成 $0$；
  + $a \& (−a)$（与 $a \& (∼(a−1))$ 等价）的结果为只保留 $a$ 的二进制表示的最后一个 $1$ ，其余的 $1$ 都变成 $0$ 。
  + 当 $n=2^k$ 时，那么 $hash\quad\&\quad(n-1)$ 等价于 $hash\quad\%\quad n$。
  + $32$ 位整数 $num$ 循环右移 $n$ 位（$n>0\quad and \quad n<32$）： $(num >>> n) | (num << (32-n))$；
  + $32$ 位整数 $num$ 循环左移 $n$ 位（$n>0\quad and \quad n<32$）： $(num << n) | (num >>> (32-n))$；
