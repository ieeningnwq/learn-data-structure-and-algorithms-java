# 并查集

## 1.1 动态连通性

现在我们输入一列整数对，其中每个整数都表示一个某种类型的对象，一堆整数`p q`可以被理解为<font color='red'><strong>p和q是相连的</strong></font>，这里<font color='red'><strong>连接</strong></font>是一种等价关系，即：

1. 自反性：`p`和`p`是相连的；
2. 对称性：如果`p`和`q`是相连的，那么`q`和`p`也是相连的；
3. 传递性：如果`p`和`q`是相连的且`q`和`r`也是相连的，那么`p`和`r`也是相连的。

等价关系可以将对象分为多个等价类，在<font color='red'><strong>连接</strong></font>等价关系种，如果两个对象（整数）相连时，它们才属于同一个等价类。为了便于叙述，我们规定，将对象（整数）称之为顶点，将整数对称为连接，将等价类称为连通分量（简称分量）。现在，输入一个整数对`p q`我们要解决两个问题：

+ <font color='red'><strong>find</strong></font>：`p`和`q`是否连接；
+ <font color='red'><strong>union</strong></font>：`p`和`q`如果不连接，那么合并`p`和`q`所在的两个集合。

## 1.2 MyUnionFind API

为了解决动态连通性的问题，我们设计了`MyUnionFind`接口展示所需的基本操作，接口定义如下所示：

|public interface|**MyUnionFind**||
|--:|:--|:--|
|void|union(int p, int q)|如果 p 和 q 不相连，那么增加一条连接|
|int|find(int p)|p 所在分量的标识符|
|boolean|connected(int p, int q)|如果 p 和 q 在同一个分量中，返回 true|
|int|count()|连通分量的数量|

## 1.3 使用什么数据结构表示已知连接

实现`MyUnionFind`接口的所有类，首先都面临同一个问题：如何表示已知连接。`API`中已经说明顶点和分量都使用`int`表示，那么，我们可以用一个以顶点为索引的数组`id[]`作为基本数据结构来表示所有分量，并且使用分量中的某个顶点的名称作为分量的标识符，因此，每个分量中的每个顶点都可以代表该分量。一开始，我们有 $N$ 个分量，每个顶点都构成了一个只含自己的分量，故此，我们将`id[i]`的初始值定为 $i$ ，其中 $i$ 在 $0$ 至 $N-1$ 之间。对于，每个顶点 $i$，我们使用`find()`方法来寻找 $i$ 所在分量，并将分量信息保存至`id[i]`中。`connected()`方法的实现只用一条语句`find(p) ==find(q)`，它返回一个布尔值。除此之外，我们还需要一个`int count`属性，记录连通分量数量。

## 1.4 quick-find 算法

### 1.4.1 quick-find 算法思想和实现

为方便判断`p`和`q`是连通的，我们规定，当且仅当`id[p]==id[q]`时，`p`和`q`才是连通的。换句话说，在同一个连通分量中，所有顶点在`id[]`数组章的值必须相等，这也就意味着，方法`connected(p,q)`只需要判断`id[p]==id[q]`即可，这个比较简单，关键是`union(p,q)`的实现。

为了实现`union(p,q)`，首先我们需要检查`p`和`q`所在连通分量是否已经存在于同一个分量中，如果是，那么直接返回，否则，我们必须将两个集合中所有顶点所对应的`id[]`值变为同一个值。为此，我们不得不遍历整个数组，将所有和`id[p]`相等的值修改为`id[q]`或者反过来，将所有和`id[q]`相等的值修改为`id[p]`。

根据上面的描述，得出`MyQuickFindUnionFind`类代码，如下所示;

```java

```

### 1.4.2 quick-find 算法分析

`find`操作速度是很快的，因为只需要访问`id[]`数组一次，时间复杂度为 $O(1)$。但是`quick-find`无法处理大型问题，因为`union`需要对每一对输入`p`和`q`，都需要扫描整个`id[]`数组。在`quick-find`算法中，每次`find()`调用只需要访问数组一次，而归并两个分量的`union()`操作访问数组的次数在 $N+3$ 到 $2N+1$ 之间。一对顶点`p`和`q`就需要 $O(N)$，那么对于动态连通性问题，时间复杂度就是 $O(N^2)$ 了。



